const bcrypt = require('bcryptjs');
const { pool } = require('../config/database');
const speakeasy = require('speakeasy');
const qrcode = require('qrcode');

/**
 * User Model - Handles all user-related database operations
 */
class User {
  constructor(data) {
    this.id = data.id;
    this.username = data.username;
    this.hashed_password = data.hashed_password;
    this.role_id = data.role_id;
    this.auth_token = data.auth_token;
    this.is_2fa_enabled = data.is_2fa_enabled;
    this.is_active = data.is_active;
    this.last_login = data.last_login;
    this.created_at = data.created_at;
    this.updated_at = data.updated_at;
  }

  /**
   * Create a new user
   */
  static async create({ username, password, confirm_password, role_id, enable_2fa = false }) {
    const connection = await pool.getConnection();
    
    try {
      // Validate passwords match
      if (password !== confirm_password) {
        throw new Error('Passwords do not match');
      }

      // Check if username already exists
      const [existingUsers] = await connection.query(
        'SELECT id FROM users WHERE LOWER(username) = LOWER(?)',
        [username]
      );

      if (existingUsers.length > 0) {
        throw new Error('Username already exists');
      }

      // Validate role exists
      const [roles] = await connection.query(
        'SELECT id, name FROM roles WHERE id = ?',
        [role_id]
      );

      if (roles.length === 0) {
        throw new Error('Invalid role specified');
      }

      await connection.beginTransaction();

      // Hash password
      const saltRounds = 12;
      const hashed_password = await bcrypt.hash(password, saltRounds);

      // Prepare 2FA if enabled
      let auth_token = null;
      let qrCodeUrl = null;

      if (enable_2fa) {
        const secret = speakeasy.generateSecret({
          name: `AdsReporting - ${username}`,
          issuer: 'Ads Reporting System',
          length: 20
        });
        
        auth_token = secret.base32;
        
        // Generate QR code
        qrCodeUrl = await qrcode.toDataURL(secret.otpauth_url);
      }

      // Insert user
      const [result] = await connection.query(
        `INSERT INTO users (username, hashed_password, role_id, auth_token, is_2fa_enabled, is_active, created_at, updated_at) 
         VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW())`,
        [username.toLowerCase(), hashed_password, role_id, auth_token, enable_2fa, true]
      );

      await connection.commit();

      // Get the created user with role information
      const user = await User.findById(result.insertId);
      
      return {
        user,
        qrCode: qrCodeUrl,
        secret: auth_token // Only return this once for setup
      };

    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }

  /**
   * Find user by ID with role information
   */
  static async findById(id) {
    const [users] = await pool.query(
      `SELECT 
        u.id,
        u.username,
        u.role_id,
        u.auth_token,
        u.is_2fa_enabled,
        u.is_active,
        u.last_login,
        u.created_at,
        u.updated_at,
        r.name as role_name,
        r.description as role_description
      FROM users u
      INNER JOIN roles r ON u.role_id = r.id
      WHERE u.id = ? AND u.is_active = 1`,
      [id]
    );

    return users.length > 0 ? new User(users[0]) : null;
  }

  /**
   * Find user by username
   */
  static async findByUsername(username) {
    const [users] = await pool.query(
      `SELECT 
        u.id,
        u.username,
        u.hashed_password,
        u.role_id,
        u.auth_token,
        u.is_2fa_enabled,
        u.is_active,
        u.last_login,
        u.created_at,
        u.updated_at,
        r.name as role_name,
        r.description as role_description
      FROM users u
      INNER JOIN roles r ON u.role_id = r.id
      WHERE LOWER(u.username) = LOWER(?) AND u.is_active = 1`,
      [username]
    );

    return users.length > 0 ? users[0] : null;
  }

  /**
   * Get all users with pagination and filtering
   */
  static async findAll({ page = 1, limit = 10, search = '', role_id = null, is_active = true } = {}) {
    const offset = (page - 1) * limit;
    
    // Build where conditions
    let whereConditions = [];
    const params = [];
    
    if (is_active !== null) {
      whereConditions.push('u.is_active = ?');
      params.push(is_active);
    }
    
    if (search) {
      whereConditions.push('u.username LIKE ?');
      params.push(`%${search}%`);
    }
    
    if (role_id) {
      whereConditions.push('u.role_id = ?');
      params.push(role_id);
    }
    
    const whereClause = whereConditions.length > 0 
      ? 'WHERE ' + whereConditions.join(' AND ')
      : '';

    // Count total users
    const countQuery = `SELECT COUNT(*) as total FROM users u ${whereClause}`;
    const [countResult] = await pool.query(countQuery, params);
    const total = countResult[0].total;

    // Get users
    const usersQuery = `
      SELECT 
        u.id,
        u.username,
        u.role_id,
        u.is_2fa_enabled,
        u.is_active,
        u.last_login,
        u.created_at,
        u.updated_at,
        r.name as role_name,
        r.description as role_description
      FROM users u
      INNER JOIN roles r ON u.role_id = r.id
      ${whereClause}
      ORDER BY u.updated_at DESC, u.created_at DESC
      LIMIT ? OFFSET ?`;

    const [users] = await pool.query(usersQuery, [...params, limit, offset]);

    return {
      users: users.map(user => new User(user)),
      pagination: {
        currentPage: page,
        totalPages: Math.ceil(total / limit),
        totalUsers: total,
        limit,
        hasNextPage: page < Math.ceil(total / limit),
        hasPrevPage: page > 1
      }
    };
  }

  /**
   * Update user
   */
  static async updateById(id, updateData) {
    const connection = await pool.getConnection();
    
    try {
      // Check if user exists
      const existingUser = await User.findById(id);
      if (!existingUser) {
        throw new Error('User not found');
      }

      await connection.beginTransaction();

      // Prepare update data
      const fieldsToUpdate = {};
      
      if (updateData.username !== undefined) {
        // Check username uniqueness
        const [duplicateUsers] = await connection.query(
          'SELECT id FROM users WHERE LOWER(username) = LOWER(?) AND id != ? AND is_active = 1',
          [updateData.username, id]
        );
        
        if (duplicateUsers.length > 0) {
          throw new Error('Username already exists');
        }
        
        fieldsToUpdate.username = updateData.username.toLowerCase();
      }

      if (updateData.password !== undefined) {
        const saltRounds = 12;
        fieldsToUpdate.hashed_password = await bcrypt.hash(updateData.password, saltRounds);
      }

      if (updateData.role_id !== undefined) {
        // Validate role exists
        const [roles] = await connection.query(
          'SELECT id FROM roles WHERE id = ?',
          [updateData.role_id]
        );
        
        if (roles.length === 0) {
          throw new Error('Invalid role specified');
        }
        
        fieldsToUpdate.role_id = updateData.role_id;
      }

      if (updateData.is_active !== undefined) {
        fieldsToUpdate.is_active = updateData.is_active;
      }

      if (Object.keys(fieldsToUpdate).length === 0) {
        throw new Error('No valid fields to update');
      }

      // Add updated_at timestamp
      fieldsToUpdate.updated_at = new Date();

      // Build update query
      const setClause = Object.keys(fieldsToUpdate).map(field => `${field} = ?`).join(', ');
      const values = [...Object.values(fieldsToUpdate), id];

      await connection.query(
        `UPDATE users SET ${setClause} WHERE id = ?`,
        values
      );

      await connection.commit();

      // Return updated user
      return await User.findById(id);

    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }

  /**
   * Delete user (soft delete)
   */
  static async deleteById(id) {
    const connection = await pool.getConnection();
    
    try {
      const user = await User.findById(id);
      if (!user) {
        throw new Error('User not found');
      }

      // Check if user is admin (protection against accidental admin deletion)
      const [adminRoles] = await connection.query(
        'SELECT id FROM roles WHERE name IN (?, ?)',
        ['admin', 'super_admin']
      );
      
      const adminRoleIds = adminRoles.map(role => role.id);
      if (adminRoleIds.includes(user.role_id)) {
        throw new Error('Cannot delete admin users');
      }

      await connection.beginTransaction();

      // Soft delete
      await connection.query(
        'UPDATE users SET is_active = 0, updated_at = NOW() WHERE id = ?',
        [id]
      );

      await connection.commit();

      return { success: true, message: `User '${user.username}' deleted successfully` };

    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }

  /**
   * Toggle user active status
   */
  static async toggleStatus(id) {
    const connection = await pool.getConnection();
    
    try {
      const [users] = await connection.query(
        'SELECT id, username, is_active, role_id FROM users WHERE id = ?',
        [id]
      );

      if (users.length === 0) {
        throw new Error('User not found');
      }

      const user = users[0];
      const newStatus = !user.is_active;

      await connection.beginTransaction();

      await connection.query(
        'UPDATE users SET is_active = ?, updated_at = NOW() WHERE id = ?',
        [newStatus, id]
      );

      await connection.commit();

      return {
        id,
        username: user.username,
        is_active: newStatus,
        message: `User ${newStatus ? 'activated' : 'deactivated'} successfully`
      };

    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }

  /**
   * Update last login timestamp
   */
  static async updateLastLogin(id) {
    await pool.query(
      'UPDATE users SET last_login = NOW() WHERE id = ?',
      [id]
    );
  }

  /**
   * Enable 2FA for user
   */
  static async enable2FA(id) {
    const connection = await pool.getConnection();
    
    try {
      const user = await User.findById(id);
      if (!user) {
        throw new Error('User not found');
      }

      if (user.is_2fa_enabled) {
        throw new Error('2FA is already enabled for this user');
      }

      // Generate new 2FA secret
      const secret = speakeasy.generateSecret({
        name: `AdsReporting - ${user.username}`,
        issuer: 'Ads Reporting System',
        length: 20
      });

      const qrCodeUrl = await qrcode.toDataURL(secret.otpauth_url);

      await connection.beginTransaction();

      // Update user with 2FA secret
      await connection.query(
        'UPDATE users SET auth_token = ?, is_2fa_enabled = 1, updated_at = NOW() WHERE id = ?',
        [secret.base32, id]
      );

      await connection.commit();

      return {
        qrCode: qrCodeUrl,
        secret: secret.base32,
        message: '2FA enabled successfully'
      };

    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }

  /**
   * Disable 2FA for user
   */
  static async disable2FA(id) {
    const connection = await pool.getConnection();
    
    try {
      const user = await User.findById(id);
      if (!user) {
        throw new Error('User not found');
      }

      if (!user.is_2fa_enabled) {
        throw new Error('2FA is not enabled for this user');
      }

      await connection.beginTransaction();

      await connection.query(
        'UPDATE users SET auth_token = NULL, is_2fa_enabled = 0, updated_at = NOW() WHERE id = ?',
        [id]
      );

      await connection.commit();

      return { message: '2FA disabled successfully' };

    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }

  /**
   * Verify 2FA token
   */
  static async verify2FA(id, token) {
    const user = await User.findByIdWithSecret(id);
    if (!user || !user.is_2fa_enabled || !user.auth_token) {
      throw new Error('2FA is not enabled for this user');
    }

    const isValid = speakeasy.totp.verify({
      secret: user.auth_token,
      encoding: 'base32',
      token: token,
      window: 2 // Allow 2 time steps tolerance
    });

    return isValid;
  }

  /**
   * Find user by ID including secret (for internal use only)
   */
  static async findByIdWithSecret(id) {
    const [users] = await pool.query(
      'SELECT id, username, auth_token, is_2fa_enabled FROM users WHERE id = ? AND is_active = 1',
      [id]
    );

    return users.length > 0 ? users[0] : null;
  }

  /**
   * Verify password
   */
  async verifyPassword(password) {
    return await bcrypt.compare(password, this.hashed_password);
  }

  /**
   * Get all available roles
   */
  static async getRoles() {
    const [roles] = await pool.query(
      'SELECT id, name, description, created_at FROM roles ORDER BY name'
    );
    return roles;
  }

  /**
   * Convert to JSON (exclude sensitive data)
   */
  toJSON() {
    const { hashed_password, auth_token, ...publicData } = this;
    return publicData;
  }
}

module.exports = User;
