const express = require('express');
const router = express.Router();
const {
  createUser,
  getAllUsers,
  getUserById,
  updateUser,
  deleteUser,
  toggleUserStatus,
  getRoles,
  enable2FA,
  disable2FA
} = require('../controllers/userController');

// Import middleware (uncomment when auth is implemented)
// const { authenticate, authorize } = require('../middleware/auth');

// Input validation middleware
const validateIdParam = (req, res, next) => {
  const id = Number(req.params.id);
  if (!Number.isInteger(id) || id <= 0) {
    return res.status(400).json({
      success: false,
      message: 'Invalid user ID - must be a positive integer',
      timestamp: new Date().toISOString()
    });
  }
  req.params.id = id;
  next();
};

// Enhanced request logging middleware with better sanitization
const requestLogger = (req, res, next) => {
  const timestamp = new Date().toISOString();
  const clientIp = req.ip || req.connection.remoteAddress || 'unknown';
  console.log(`[${timestamp}] ${req.method} ${req.originalUrl} - IP: ${clientIp}`);
  if (req.body && Object.keys(req.body).length > 0) {
    const sanitizedBody = { ...req.body };
    // Hide sensitive fields
    const sensitiveFields = ['password', 'confirm_password', 'confirmPassword', 'token', 'hashed_password', 'secret'];
    Object.keys(sanitizedBody).forEach(field => {
      if (sensitiveFields.includes(field)) sanitizedBody[field] = '[HIDDEN]';
    });
    console.log('Request Body:', JSON.stringify(sanitizedBody, null, 2));
  }
  if (req.query && Object.keys(req.query).length > 0) {
    console.log('Query Parameters:', JSON.stringify(req.query, null, 2));
  }
  next();
};

// Enhanced rate limiting with memory cleanup
const createRateLimit = (windowMs = 15 * 60 * 1000, max = 100, message = 'Too many requests') => {
  const requests = new Map();
  
  // Cleanup old entries every 5 minutes
  setInterval(() => {
    const now = Date.now();
    for (const [key, value] of requests.entries()) {
      if (now > value.resetTime) {
        requests.delete(key);
      }
    }
  }, 5 * 60 * 1000);
  
  return (req, res, next) => {
    const clientId = req.ip || req.connection.remoteAddress || 'unknown';
    const now = Date.now();
    
    if (!requests.has(clientId)) {
      requests.set(clientId, { count: 1, resetTime: now + windowMs });
      return next();
    }
    
    const clientData = requests.get(clientId);
    
    if (now > clientData.resetTime) {
      clientData.count = 1;
      clientData.resetTime = now + windowMs;
      return next();
    }
    
    if (clientData.count >= max) {
      return res.status(429).json({
        success: false,
        message,
        retryAfter: Math.ceil((clientData.resetTime - now) / 1000),
        timestamp: new Date().toISOString()
      });
    }
    
    clientData.count++;
    next();
  };
};

// Request body size validation middleware
const validateRequestSize = (req, res, next) => {
  const contentLength = req.get('content-length');
  if (contentLength && Number(contentLength) > 1024 * 1024) { // 1MB limit
    return res.status(413).json({
      success: false,
      message: 'Request body too large',
      timestamp: new Date().toISOString()
    });
  }
  next();
};

// Apply global middleware
router.use(requestLogger);
router.use(validateRequestSize);

// =============================================================================
// PUBLIC ROUTES (No authentication required)
// =============================================================================

/**
 * @route   POST /users
 * @desc    Create a new user
 * @access  Public (will be protected later)
 * @body    { username, password, role_id }
 */
router.post('/', 
  createRateLimit(15 * 60 * 1000, 5, 'Too many user creation attempts. Please try again later.'),
  createUser
);

// =============================================================================
// PROTECTED ROUTES (Authentication required)
// =============================================================================
// Note: Uncomment the middleware below when authentication is implemented
// router.use(authenticate); // Require valid JWT token

/**
 * @route   GET /users
 * @desc    Get all users with pagination, search, and filtering
 * @access  Protected
 * @query   ?page=1&limit=10&search=username&role_id=1
 */
router.get('/', 
  createRateLimit(5 * 60 * 1000, 100, 'Too many requests to fetch users'),
  getAllUsers
);

/**
 * @route   GET /users/:id
 * @desc    Get specific user by ID
 * @access  Protected
 * @params  id - User ID (positive integer)
 */
router.get('/:id', 
  validateIdParam,
  createRateLimit(5 * 60 * 1000, 200, 'Too many requests to fetch user details'),
  getUserById
);

/**
 * @route   PUT /users/:id
 * @desc    Update user information
 * @access  Protected (Admin/Manager)
 * @params  id - User ID
 * @body    { username?, password?, role_id? }
 */
router.put('/:id', 
  validateIdParam,
  createRateLimit(15 * 60 * 1000, 30, 'Too many user update attempts'),
  // authorize(['admin', 'manager']), // Uncomment when role-based auth is implemented
  updateUser
);

/**
 * @route   DELETE /users/:id
 * @desc    Soft delete user (set is_active = false)
 * @access  Protected (Admin only)
 * @params  id - User ID
 */
router.delete('/:id', 
  validateIdParam,
  createRateLimit(60 * 60 * 1000, 10, 'Too many user deletion attempts'),
  // authorize(['admin']), // Only admin can delete - uncomment when auth is ready
  deleteUser
);

/**
 * @route   PATCH /users/:id/toggle-status
 * @desc    Toggle user active status
 * @access  Protected (Admin only)
 * @params  id - User ID
 */
router.patch('/:id/toggle-status', 
  validateIdParam,
  createRateLimit(15 * 60 * 1000, 20, 'Too many status toggle attempts'),
  // authorize(['admin']), // Only admin can toggle status
  toggleUserStatus
);

/**
 * @route   POST /users/:id/enable-2fa
 * @desc    Enable 2FA for user
 * @access  Protected (Admin or self)
 * @params  id - User ID
 */
router.post('/:id/enable-2fa', 
  validateIdParam,
  createRateLimit(60 * 60 * 1000, 5, 'Too many 2FA enable attempts'),
  // authorize(['admin', 'manager', 'user']),
  enable2FA
);

/**
 * @route   POST /users/:id/disable-2fa
 * @desc    Disable 2FA for user
 * @access  Protected (Admin or self)
 * @params  id - User ID
 */
router.post('/:id/disable-2fa', 
  validateIdParam,
  createRateLimit(60 * 60 * 1000, 5, 'Too many 2FA disable attempts'),
  // authorize(['admin', 'manager', 'user']),
  disable2FA
);

// =============================================================================
// UTILITY ROUTES
// =============================================================================

/**
 * @route   GET /users/roles
 * @desc    Get all available roles
 * @access  Protected
 */
router.get('/roles', 
  createRateLimit(5 * 60 * 1000, 50, 'Too many roles requests'),
  getRoles
);

/**
 * @route   GET /users/check/username/:username
 * @desc    Check if username is available
 * @access  Public
 * @params  username - Username to check
 */
router.get('/check/username/:username', 
  createRateLimit(5 * 60 * 1000, 50, 'Too many username availability checks'),
  async (req, res) => {
    try {
      const { username } = req.params;
      
      if (!username || username.length < 3 || username.length > 30) {
        return res.status(400).json({
          success: false,
          message: 'Username must be between 3 and 30 characters',
          timestamp: new Date().toISOString()
        });
      }

      const { pool } = require('../config/database');
      const [users] = await pool.query(
        'SELECT id FROM users WHERE LOWER(username) = LOWER(?) AND is_active = 1',
        [username]
      );

      res.status(200).json({
        success: true,
        message: 'Username availability checked',
        data: {
          username,
          available: users.length === 0
        },
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      console.error('Username check error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to check username availability',
        timestamp: new Date().toISOString()
      });
    }
  }
);

/**
 * @route   GET /users/stats
 * @desc    Get user statistics
 * @access  Protected (Admin/Manager)
 */
router.get('/stats', 
  createRateLimit(5 * 60 * 1000, 20, 'Too many stats requests'),
  // authorize(['admin', 'manager']),
  async (req, res) => {
    try {
      const { pool } = require('../config/database');
      
      const [stats] = await pool.query(`
        SELECT 
          COUNT(*) as total_users,
          SUM(CASE WHEN is_active = 1 THEN 1 ELSE 0 END) as active_users,
          SUM(CASE WHEN is_active = 0 THEN 1 ELSE 0 END) as inactive_users,
          COUNT(DISTINCT role_id) as unique_roles,
          SUM(CASE WHEN last_login >= DATE_SUB(NOW(), INTERVAL 30 DAY) THEN 1 ELSE 0 END) as recent_logins
        FROM users
      `);

      const [roleStats] = await pool.query(`
        SELECT 
          r.role_name,
          COUNT(u.id) as user_count
        FROM roles r
        LEFT JOIN users u ON r.id = u.role_id AND u.is_active = 1
        WHERE r.is_active = 1
        GROUP BY r.id, r.role_name
        ORDER BY user_count DESC
      `);

      res.status(200).json({
        success: true,
        message: 'User statistics retrieved successfully',
        data: {
          overview: stats[0],
          roleDistribution: roleStats
        },
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      console.error('User stats error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to retrieve user statistics',
        timestamp: new Date().toISOString()
      });
    }
  }
);

// =============================================================================
// ERROR HANDLING
// =============================================================================

// Handle invalid routes - Enhanced with better route documentation
router.use((req, res) => {
  res.status(404).json({
    success: false,
    message: `Route ${req.method} ${req.originalUrl} not found`,
    availableRoutes: {
      'POST /users': 'Create new user',
      'GET /users': 'Get all users (with pagination, search, filtering)',
      'GET /users/:id': 'Get user by ID',
      'PUT /users/:id': 'Update user',
      'DELETE /users/:id': 'Soft delete user',
      'PATCH /users/:id/toggle-status': 'Toggle user active status',
      'GET /users/check/username/:username': 'Check username availability',
      'GET /users/stats': 'Get user statistics'
    },
    timestamp: new Date().toISOString()
  });
});

// Enhanced global error handler
router.use((error, req, res, next) => {
  const timestamp = new Date().toISOString();
  console.error(`[${timestamp}] User routes error:`, {
    url: req.originalUrl,
    method: req.method,
    ip: req.ip,
    error: error.message,
    stack: error.stack
  });
  // Handle specific error types
  if (error.name === 'ValidationError' || error.isJoi) {
    return res.status(400).json({
      success: false,
      message: 'Validation error',
      errors: error.details || [error.message],
      timestamp
    });
  }
  if (error.code === 'ETIMEDOUT') {
    return res.status(408).json({
      success: false,
      message: 'Request timeout',
      timestamp
    });
  }
  res.status(500).json({
    success: false,
    message: 'Internal server error in user management',
    timestamp,
    ...(process.env.NODE_ENV === 'development' && {
      error: error.message,
      stack: error.stack
    })
  });
});

module.exports = router;
