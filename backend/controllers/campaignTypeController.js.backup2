const { pool } = require('../config/database');

// =============================================================================
// HELPERS
// =============================================================================

const createResponse = (success, message, data = null, meta = null) => {
  const response = {
    success,
    message,
    timestamp: new Date().toISOString()
  };
  if (data !== null) response.data = data;
  if (meta !== null) response.meta = meta;
  return response;
};

const handleDatabaseError = (error, operation = 'database operation') => {
  console.error(`[CampaignTypeController] Error during ${operation}:`, error);

  if (error && error.code === 'ER_DUP_ENTRY') {
    return {
      statusCode: 409,
      response: createResponse(false, 'Campaign type name already exists. Please use a different name.')
    };
  }

  if (error && error.code === 'ER_NO_SUCH_TABLE') {
    return {
      statusCode: 500,
      response: createResponse(false, 'Database table not found. Please contact administrator.')
    };
  }

  if (error && error.code === 'ECONNREFUSED') {
    return {
      statusCode: 503,
      response: createResponse(false, 'Database connection failed. Please try again later.')
    };
  }

  if (error && error.code === 'ER_ACCESS_DENIED_ERROR') {
    return {
      statusCode: 500,
      response: createResponse(false, 'Database access denied. Please contact administrator.')
    };
  }

  return {
    statusCode: 500,
    response: createResponse(
      false,
      'Database error occurred. Please try again later.',
      null,
      process.env.NODE_ENV === 'development' ? { error: error.message, code: error.code } : null
    )
  };
};

const normalizeBooleanToBit = (val, defaultVal = null) => {
  if (val === undefined || val === null) return defaultVal;
  return val ? 1 : 0;
};

const buildSearchConditions = (search, status) => {
  const where = [];
  const params = [];

  if (search) {
    where.push('(type_name LIKE ? OR description LIKE ?)');
    const term = `%${search}%`;
    params.push(term, term);
  }

  if (status && status !== 'all') {
    where.push('is_active = ?');
    params.push(status === 'active' ? 1 : 0);
  }

  const whereClause = where.length ? `WHERE ${where.join(' AND ')}` : '';
  return { whereClause, queryParams: params };
};

// Strict whitelist for updatable columns
const UPDATABLE_FIELDS = new Set(['type_name', 'description', 'is_active']);

// =============================================================================
// CRUD
// =============================================================================

/**
 * POST /api/campaign-types
 */
const createCampaignType = async (req, res) => {
  let connection;
  try {
    const body = req.validatedData || req.body || {};
    const type_name = (body.type_name || '').trim();
    const description = (body.description || '').trim();
    const is_active = normalizeBooleanToBit(body.is_active, 1);

    if (!type_name) {
      return res.status(400).json(createResponse(false, 'type_name is required'));
    }

    connection = await pool.getConnection();
    await connection.beginTransaction();

    const [result] = await connection.execute(
      `INSERT INTO campaign_types (type_name, description, is_active, created_at, updated_at)
       VALUES (?, ?, ?, NOW(), NOW())`,
      [type_name, description, is_active]
    );

    if (!result.insertId) {
      await connection.rollback();
      return res.status(500).json(createResponse(false, 'Failed to create campaign type'));
    }

    const [rows] = await connection.execute(
      `SELECT id, type_name, description, is_active, created_at, updated_at
       FROM campaign_types
       WHERE id = ?`,
      [result.insertId]
    );

    await connection.commit();

    const data = rows && rows[0] ? rows[0] : null;
    return res.status(201).json(
      createResponse(true, 'Campaign type created successfully', data)
    );
  } catch (error) {
    if (connection) await connection.rollback();
    const { statusCode, response } = handleDatabaseError(error, 'campaign type creation');
    return res.status(statusCode).json(response);
  } finally {
    if (connection) connection.release();
  }
};

/**
 * GET /api/campaign-types
 * FIXED: Parameter handling for MySQL execute
 */
const getAllCampaignTypes = async (req, res) => {
  try {
    const query = req.validatedQuery || req.query || {};
    const page = Math.max(1, parseInt(query.page, 10) || 1);
    const limit = Math.min(100, Math.max(1, parseInt(query.limit, 10) || 10));
    const search = (query.search || '').trim() || null;
    const status = query.status || 'all';
    const offset = (page - 1) * limit;

    const { whereClause, queryParams } = buildSearchConditions(search, status);

    // Count query
    const countQuery = `SELECT COUNT(*) AS total FROM campaign_types ${whereClause}`;
    const [countRows] = await pool.execute(countQuery, queryParams || []);
    const totalCount = (countRows && countRows[0] && Number(countRows[0].total)) || 0;

    // Main query - combine queryParams with pagination params
    const selectQuery = `SELECT id, type_name, description, is_active, created_at, updated_at
       FROM campaign_types
       ${whereClause}
       ORDER BY created_at DESC
       LIMIT ? OFFSET ?`;
    
    // Build parameters array: concat search params with pagination params
    const selectParams = [...(queryParams || []), limit, offset];
    
    const [rows] = await pool.execute(selectQuery, selectParams);

    const totalPages = Math.max(1, Math.ceil(totalCount / limit));
    const meta = {
      pagination: {
        currentPage: page,
        totalPages,
        totalCount,
        limit,
        hasNext: page < totalPages,
        hasPrev: page > 1
      },
      filters: {
        search: search || null,
        status
      }
    };

    return res.status(200).json(
      createResponse(true, `Retrieved ${rows.length} campaign type(s)`, rows, meta)
    );
  } catch (error) {
    const { statusCode, response } = handleDatabaseError(error, 'campaign types retrieval');
    return res.status(statusCode).json(response);
  }
};

/**
 * GET /api/campaign-types/:id
 */
const getCampaignTypeById = async (req, res) => {
  try {
    const params = req.validatedParams || req.params || {};
    const id = parseInt(params.id, 10);
    if (!id || isNaN(id) || id <= 0) {
      return res.status(400).json(createResponse(false, 'Invalid campaign type ID'));
    }

    const [rows] = await pool.execute(
      `SELECT id, type_name, description, is_active, created_at, updated_at
       FROM campaign_types
       WHERE id = ?`,
      [id]
    );

    if (!rows || rows.length === 0) {
      return res.status(404).json(createResponse(false, 'Campaign type not found'));
    }

    const data = rows && rows[0] ? rows[0] : null;
    return res.status(200).json(
      createResponse(true, 'Campaign type retrieved successfully', data)
    );
  } catch (error) {
    const { statusCode, response } = handleDatabaseError(error, 'campaign type retrieval');
    return res.status(statusCode).json(response);
  }
};

/**
 * PUT /api/campaign-types/:id
 */
const updateCampaignType = async (req, res) => {
  let connection;
  try {
    const params = req.validatedParams || req.params || {};
    const id = parseInt(params.id, 10);
    if (!id || isNaN(id) || id <= 0) {
      return res.status(400).json(createResponse(false, 'Invalid campaign type ID'));
    }

    const body = req.validatedData || req.body || {};
    const updateData = {};

    if (Object.prototype.hasOwnProperty.call(body, 'type_name')) {
      const v = (body.type_name || '').trim();
      if (!v) return res.status(400).json(createResponse(false, 'type_name cannot be empty'));
      updateData.type_name = v;
    }
    if (Object.prototype.hasOwnProperty.call(body, 'description')) {
      updateData.description = (body.description || '').trim();
    }
    if (Object.prototype.hasOwnProperty.call(body, 'is_active')) {
      updateData.is_active = normalizeBooleanToBit(body.is_active, null);
    }

    const fields = Object.keys(updateData).filter(k => UPDATABLE_FIELDS.has(k));
    if (fields.length === 0) {
      return res.status(400).json(createResponse(false, 'No valid fields provided for update'));
    }

    connection = await pool.getConnection();
    await connection.beginTransaction();

    const [existing] = await connection.execute(
      `SELECT id FROM campaign_types WHERE id = ?`,
      [id]
    );
    if (!existing || existing.length === 0) {
      await connection.rollback();
      return res.status(404).json(createResponse(false, 'Campaign type not found'));
    }

    const setParts = [];
    const values = [];
    for (const key of fields) {
      setParts.push(`${key} = ?`);
      values.push(updateData[key]);
    }
    setParts.push('updated_at = NOW()');
    values.push(id);

    await connection.execute(
      `UPDATE campaign_types SET ${setParts.join(', ')} WHERE id = ?`,
      values
    );

    const [updated] = await connection.execute(
      `SELECT id, type_name, description, is_active, created_at, updated_at
       FROM campaign_types WHERE id = ?`,
      [id]
    );

    await connection.commit();

    const data = updated && updated[0] ? updated[0] : null;
    return res.status(200).json(
      createResponse(true, 'Campaign type updated successfully', data)
    );
  } catch (error) {
    if (connection) await connection.rollback();
    const { statusCode, response } = handleDatabaseError(error, 'campaign type update');
    return res.status(statusCode).json(response);
  } finally {
    if (connection) connection.release();
  }
};

/**
 * DELETE /api/campaign-types/:id (soft delete)
 */
const deleteCampaignType = async (req, res) => {
  let connection;
  try {
    const params = req.validatedParams || req.params || {};
    const id = parseInt(params.id, 10);
    if (!id || isNaN(id) || id <= 0) {
      return res.status(400).json(createResponse(false, 'Invalid campaign type ID'));
    }

    connection = await pool.getConnection();
    await connection.beginTransaction();

    const [existing] = await connection.execute(
      `SELECT id, type_name, is_active FROM campaign_types WHERE id = ?`,
      [id]
    );
    if (!existing || existing.length === 0) {
      await connection.rollback();
      return res.status(404).json(createResponse(false, 'Campaign type not found'));
    }

    const row = existing[0];

    if (row.is_active === 0) {
      await connection.rollback();
      return res.status(200).json(
        createResponse(true, 'Campaign type is already inactive', {
          id,
          type_name: row.type_name,
          deleted_at: null
        })
      );
    }

    const [result] = await connection.execute(
      `UPDATE campaign_types SET is_active = 0, updated_at = NOW() WHERE id = ?`,
      [id]
    );
    if (!result || result.affectedRows === 0) {
      await connection.rollback();
      return res.status(500).json(createResponse(false, 'Failed to delete campaign type'));
    }

    await connection.commit();

    return res.status(200).json(
      createResponse(true, 'Campaign type deleted successfully', {
        id,
        type_name: row.type_name,
        deleted_at: new Date().toISOString()
      })
    );
  } catch (error) {
    if (connection) await connection.rollback();
    const { statusCode, response } = handleDatabaseError(error, 'campaign type deletion');
    return res.status(statusCode).json(response);
  } finally {
    if (connection) connection.release();
  }
};

// =============================================================================
// EXPORTS
// =============================================================================

module.exports = {
  createCampaignType,
  getAllCampaignTypes,
  getCampaignTypeById,
  updateCampaignType,
  deleteCampaignType
};
